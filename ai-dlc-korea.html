<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 주도 개발 라이프사이클 (AI-DLC) 방법론 정의</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Malgun Gothic', sans-serif;
            line-height: 1.8;
            color: #333;
            background: linear-gradient(to bottom, #f8f9fa, #ffffff);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
            border-radius: 12px;
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #232F3E, #FF9900);
            color: white;
            padding: 60px 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        header .subtitle {
            font-size: 1.2em;
            opacity: 0.95;
            font-weight: 300;
        }

        .content {
            padding: 50px 40px;
        }

        h2 {
            color: #232F3E;
            font-size: 2em;
            margin: 50px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #FF9900;
        }

        h3 {
            color: #FF9900;
            font-size: 1.5em;
            margin: 30px 0 15px 0;
        }

        h4 {
            color: #232F3E;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        p {
            margin: 15px 0;
            text-align: justify;
        }

        ul, ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin: 10px 0;
        }

        .principle-box {
            background: #f8f9fa;
            border-left: 4px solid #FF9900;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .principle-box h3 {
            margin-top: 0;
            color: #232F3E;
        }

        .artifact-card {
            background: linear-gradient(to right, #f8f9fa, #ffffff);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .artifact-card h4 {
            color: #FF9900;
            margin-top: 0;
        }

        .phase-section {
            background: #fff5e6;
            padding: 30px;
            margin: 30px 0;
            border-radius: 8px;
            border: 2px solid #FF9900;
        }

        .phase-section h3 {
            color: #232F3E;
            margin-top: 0;
        }

        .workflow-diagram {
            background: white;
            padding: 30px;
            margin: 30px 0;
            border: 2px dashed #FF9900;
            border-radius: 8px;
            text-align: center;
        }

        .code-block {
            background: #232F3E;
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
        }

        .note {
            background: #e7f3ff;
            border-left: 4px solid #0066cc;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid #dee2e6;
        }

        th {
            background: #232F3E;
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        footer {
            background: #232F3E;
            color: white;
            padding: 30px 40px;
            text-align: center;
        }

        .toc {
            background: #f8f9fa;
            padding: 30px;
            margin: 30px 0;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .toc h3 {
            color: #232F3E;
            margin-top: 0;
        }

        .toc ul {
            list-style: none;
            margin-left: 0;
        }

        .toc li {
            margin: 8px 0;
        }

        .toc a {
            color: #0066cc;
            text-decoration: none;
            transition: color 0.3s;
        }

        .toc a:hover {
            color: #FF9900;
            text-decoration: underline;
        }

        .diagram-image {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 30px auto;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }

            .content {
                padding: 30px 20px;
            }

            h2 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>AI 주도 개발 라이프사이클 (AI-DLC)</h1>
            <p class="subtitle">방법론 정의</p>
            <p style="margin-top: 20px; font-size: 0.9em;">Raja SP, Amazon Web Services</p>
        </header>

        <div class="content">
            <!-- 목차 -->
            <div class="toc">
                <h3>📑 목차</h3>
                <ul>
                    <li><a href="#context">I. 배경</a></li>
                    <li><a href="#principles">II. 핵심 원칙</a></li>
                    <li><a href="#framework">III. 핵심 프레임워크</a></li>
                    <li><a href="#greenfield">IV. AI-DLC 실전: 그린필드 개발</a></li>
                    <li><a href="#brownfield">V. AI-DLC 실전: 브라운필드 개발</a></li>
                    <li><a href="#adoption">VI. AI-DLC 도입</a></li>
                    <li><a href="#appendix">부록 A: 프롬프트 예시</a></li>
                </ul>
            </div>

            <!-- I. 배경 -->
            <section id="context">
                <h2>I. 배경</h2>
                <p>
                    소프트웨어 엔지니어링의 진화는 개발자들이 저수준의 차별화되지 않은 작업에서 벗어나
                    복잡한 문제 해결에 집중할 수 있도록 하는 지속적인 여정이었습니다. 초기 기계어 코드에서
                    고급 프로그래밍 언어, API 및 라이브러리 채택에 이르기까지, 각 단계는 개발자 생산성을
                    크게 향상시켰습니다.
                </p>
                <p>
                    이제 <span class="highlight">대규모 언어 모델(LLM)</span>의 통합은 소프트웨어 생성 방식을
                    혁신하여 코드 생성, 버그 감지, 테스트 생성과 같은 작업에 대화형 자연어 상호작용을 도입했습니다.
                    이는 AI가 세분화된 특정 작업을 향상시키는 <strong>AI 지원(AI-Assisted) 시대</strong>를 의미합니다.
                </p>
                <p>
                    AI가 발전함에 따라, 그 응용 분야는 코드 생성을 넘어 요구사항 정교화, 계획, 작업 분해, 설계,
                    개발자와의 실시간 협업까지 확장되고 있습니다. 이러한 변화는 AI가 개발 프로세스를 적극적으로
                    조율하는 <strong>AI 주도(AI-Driven) 시대</strong>를 시작하고 있습니다.
                </p>
                <div class="note">
                    <strong>💡 핵심 인사이트:</strong> 기존 소프트웨어 개발 방법론은 인간 주도의 장기 실행 프로세스를
                    위해 설계되었으며, AI의 속도, 유연성, 고급 기능(예: 에이전트)과 완전히 일치하지 않습니다.
                    AI를 기존 방법에 끼워 맞추는 것은 잠재력을 제한할 뿐만 아니라 구식 비효율성을 강화합니다.
                </div>
                <p>
                    본 논문은 AI의 역량을 완전히 통합하도록 설계된 <strong>AI 네이티브 방법론</strong>인
                    <span class="highlight">AI 주도 개발 라이프사이클(AI-DLC)</span>을 소개하고 정의하여,
                    소프트웨어 엔지니어링의 다음 진화를 위한 기초를 마련합니다.
                </p>
            </section>

            <!-- II. 핵심 원칙 -->
            <section id="principles">
                <h2>II. 핵심 원칙</h2>
                <p>
                    이 섹션의 원칙들은 AI-DLC를 정의하는 기초를 형성하며, 단계, 역할, 산출물, 의식(rituals)을
                    구체화합니다. 이러한 가정은 제안된 방법을 검증하는 데 중요하며, 설계의 근거를 제공합니다.
                </p>

                <div class="principle-box">
                    <h3>1. 개조가 아닌 재상상</h3>
                    <p>
                        우리는 Scrum과 같은 기존 방법(SDLC 또는 Agile)을 유지하고 AI를 끼워 맞추는 대신
                        개발 방법을 재상상하기로 선택합니다. 이러한 전통적인 방법은 더 긴 반복 기간(몇 달 및 몇 주)을
                        위해 구축되어 일일 스탠드업 및 회고와 같은 의식으로 이어졌습니다.
                    </p>
                    <p>
                        반면, AI를 적절히 적용하면 몇 시간 또는 며칠 단위로 측정되는 빠른 주기로 이어집니다.
                        이는 지속적이고 실시간 검증 및 피드백 메커니즘이 필요하며, 많은 전통적인 의식을 덜 관련성 있게 만듭니다.
                    </p>
                    <p class="highlight">
                        💡 우리는 더 빠른 말 전차가 아닌 자동차가 필요합니다.
                    </p>
                </div>

                <div class="principle-box">
                    <h3>2. 대화 방향 역전</h3>
                    <p>
                        AI-DLC는 인간이 AI와 대화를 시작하는 대신 <strong>AI가 인간과의 대화를 시작하고
                        지시하는</strong> 근본적인 전환을 도입합니다.
                    </p>
                    <p>
                        AI는 상위 수준 의도(예: 새로운 비즈니스 기능 구현)를 실행 가능한 작업으로 분해하고,
                        권장 사항을 생성하고, 트레이드오프를 제안하여 워크플로를 주도합니다. 인간은 승인자 역할을 하며,
                        중요한 시점에서 검증하고 옵션을 선택하고 결정을 확인합니다.
                    </p>
                    <div class="note">
                        <strong>🗺️ 비유:</strong> Google Maps처럼 - 인간이 목적지(의도)를 설정하면,
                        시스템이 단계별 지침(AI의 작업 분해 및 권장 사항)을 제공합니다.
                        그 과정에서 인간은 감독을 유지하고 필요에 따라 여정을 조정합니다.
                    </div>
                </div>

                <div class="principle-box">
                    <h3>3. 설계 기법을 핵심에 통합</h3>
                    <p>
                        Scrum이나 Kanban과 같은 Agile 프레임워크는 설계 기법(예: 도메인 주도 설계)을
                        범위 밖으로 두고 팀이 자체적으로 선택하도록 권장합니다. 이는 전반적으로 소프트웨어 품질
                        저하로 이어진 중요한 공백을 남겼습니다.
                    </p>
                    <p>
                        2022년 미국에서만 소프트웨어 품질 문제로 인한 비용이 <strong>2.41조 달러</strong>로
                        추정되었습니다. 설계 기법을 분리하는 대신, AI-DLC는 이를 핵심으로 통합합니다.
                    </p>
                    <p>
                        AI-DLC에는 도메인 주도 설계(DDD), 행동 주도 개발(BDD), 테스트 주도 개발(TDD)을
                        각각 따르는 팀을 위한 다양한 버전이 있을 것입니다.
                    </p>
                </div>

                <div class="principle-box">
                    <h3>4. AI 역량과 정렬</h3>
                    <p>
                        본 논문은 AI의 미래 잠재력에 대해 낙관적이지만 현재 상태에 대해 완전히 현실적입니다.
                        AI-DLC는 현재 AI가 발전하고 있지만 아직 독립적으로 높은 수준의 의도를 실행 가능한 코드로
                        번역하거나 해석 가능성과 안전성을 보장하면서 인간 감독 없이 독립적으로 작동할 만큼
                        신뢰할 수 없다는 것을 인식합니다.
                    </p>
                    <p>
                        AI-DLC는 인간 참여와 현재 AI의 역량 및 한계를 균형 있게 조정하는
                        <strong>AI 주도(AI-Driven) 패러다임</strong>을 채택합니다.
                        이 방식에서 개발자는 검증, 의사 결정, 감독에 대한 궁극적인 책임을 유지합니다.
                    </p>
                </div>

                <div class="principle-box">
                    <h3>5. 복잡한 시스템 구축에 초점</h3>
                    <p>
                        AI-DLC는 지속적인 기능적 적응성, 높은 아키텍처 복잡성, 수많은 트레이드오프 관리,
                        확장성, 통합 및 사용자 정의 요구 사항을 요구하는 시스템 구축에 중점을 둡니다.
                    </p>
                    <p>
                        이는 일반적으로 대규모 및/또는 규제된 조직 내에서 응집력 있게 작업하는 여러 팀을 포함하는
                        고급 설계 기법, 패턴 및 모범 사례의 적용을 필요로 합니다.
                    </p>
                </div>

                <div class="principle-box">
                    <h3>6. 인간 공생을 강화하는 요소 유지</h3>
                    <p>
                        방법을 재상상하는 동안, 인간 검증 및 위험 완화에 중요한 기존 방법의 산출물과
                        접점을 유지할 것입니다.
                    </p>
                    <p>
                        예를 들어, <strong>사용자 스토리</strong>는 인간과 AI가 무엇을 구축해야 하는지에 대한
                        이해를 일치시켜 잘 정의된 계약 역할을 합니다. 또 다른 예는 AI 생성 계획과 코드가
                        조직의 위험 프레임워크를 준수하도록 보장하는 <strong>위험 등록부(Risk Register)</strong>입니다.
                    </p>
                </div>

                <div class="principle-box">
                    <h3>7. 친숙함을 통한 전환 촉진</h3>
                    <p>
                        새로운 방법은 광범위한 교육을 요구해서는 안 되며, 기존 실무자는 하루 만에 이를
                        익히고 실천할 수 있어야 합니다.
                    </p>
                    <p>
                        연관 학습을 통한 보다 쉬운 채택을 지원하기 위해, AI-DLC는 현대화된 용어를 도입하면서
                        이전 방법의 익숙한 용어 간의 기본 관계를 보존합니다.
                    </p>
                    <p class="highlight">
                        예: Scrum의 스프린트(Sprints)는 반복 주기를 나타냅니다. 그러나 스프린트는
                        일반적으로 4~6주 동안 지속됩니다. AI-DLC에서는 반복 주기가 지속적이고 몇 시간 또는
                        며칠 단위입니다. 따라서 스프린트를 <strong>Bolts</strong>로 이름을 변경하여
                        전례 없는 속도를 제공하는 빠르고 강렬한 주기를 강조합니다.
                    </p>
                </div>

                <div class="principle-box">
                    <h3>8. 효율성을 위한 책임 간소화</h3>
                    <p>
                        AI의 작업 분해 및 의사 결정 수행 능력을 활용하여, 개발자는 인프라, 프론트엔드,
                        백엔드, DevOps, 보안과 같은 전통적인 전문화 사일로를 초월할 수 있게 됩니다.
                    </p>
                    <p>
                        이러한 책임의 수렴은 여러 전문 역할의 필요성을 줄여 개발 프로세스를 간소화합니다.
                        그러나 <strong>제품 소유자와 개발자</strong>는 프레임워크에 필수적으로 남아 있으며,
                        감독, 검증 및 전략적 의사 결정에 대한 중요한 책임을 유지합니다.
                    </p>
                </div>

                <div class="principle-box">
                    <h3>9. 단계 최소화, 흐름 최대화</h3>
                    <p>
                        자동화 및 책임 수렴을 통해 AI-DLC는 핸드오프와 전환을 최소화하여
                        지속적인 반복 흐름을 가능하게 하는 것을 목표로 합니다.
                    </p>
                    <p>
                        그러나 인간 검증 및 의사 결정은 AI 생성 코드가 경직되지 않고('quick-cement')
                        향후 반복을 위해 적응 가능한 상태로 유지되도록 보장하는 데 중요합니다.
                    </p>
                    <p>
                        이를 해결하기 위해 AI-DLC는 중요한 결정 지점에서 인간 감독을 위해 특별히 설계된
                        최소한이지만 충분한 수의 단계를 통합합니다. 이러한 검증은 발생하기 전에
                        낭비적인 다운스트림 노력을 식별하고 정리하여 일종의 '손실 함수(loss function)'로 작용합니다.
                    </p>
                </div>

                <div class="principle-box">
                    <h3>10. 하드코딩된 독단적인 SDLC 워크플로 없음</h3>
                    <p>
                        AI-DLC는 다양한 개발 경로(예: 새로운 시스템 개발, 리팩토링, 결함 수정 또는
                        마이크로서비스 확장)에 대한 독단적인 워크플로를 규정하지 않습니다.
                    </p>
                    <p>
                        대신 AI가 주어진 경로 의도에 따라 <strong>레벨 1 계획</strong>을 권장하는
                        진정한 AI 우선 접근 방식을 채택합니다. 인간은 AI와의 대화형 대화를 통해
                        이러한 AI 생성 계획을 확인하고 조정합니다.
                    </p>
                </div>
            </section>

            <!-- III. 핵심 프레임워크 -->
            <section id="framework">
                <h2>III. 핵심 프레임워크</h2>
                <p>
                    이 섹션은 AI-DLC의 핵심 프레임워크를 설명하며, 단계, 역할, 워크플로 및 주요 산출물을 상세히 다룹니다.
                </p>

                <img src="ai_dlc.png" alt="AI-DLC 핵심 프레임워크" class="diagram-image">

                <h3>1. 산출물 (Artifacts)</h3>

                <div class="artifact-card">
                    <h4>의도 (Intent)</h4>
                    <p>
                        AI-DLC의 <strong>의도(Intent)</strong>는 비즈니스 목표, 기능 또는 기술 결과(예: 성능 확장)이든
                        달성해야 할 것을 캡슐화하는 높은 수준의 목적 진술입니다.
                    </p>
                    <p>
                        이는 AI 주도 분해를 통해 실행 가능한 작업으로 전환하는 시작점 역할을 하며,
                        인간의 목표를 AI 생성 계획과 일치시킵니다.
                    </p>
                </div>

                <div class="artifact-card">
                    <h4>유닛 (Unit)</h4>
                    <p>
                        <strong>유닛(Unit)</strong>은 의도에서 파생된 응집력 있고 자체 포함된 작업 요소로,
                        측정 가능한 가치를 제공하도록 특별히 설계되었습니다.
                    </p>
                    <p>
                        예를 들어, 비즈니스 아이디어를 구현하는 의도는 DDD의 하위 도메인 또는 Scrum의 에픽과
                        유사한 독립적인 기능 블록을 나타내는 유닛으로 분해될 수 있습니다.
                    </p>
                    <p>
                        각 유닛은 기능적 범위를 명시하는 일련의 작업(이 경우 사용자 스토리)을 포함합니다.
                        AI-DLC의 맥락에서 의도를 유닛으로 분해하는 프로세스는 AI에 의해 주도되며,
                        개발자 및/또는 제품 소유자가 결과 유닛을 검증하고 개선하여 비즈니스 및 기술 목표와의
                        일치를 보장합니다.
                    </p>
                    <p class="highlight">
                        💡 유닛은 느슨하게 결합되어 있어 자율적인 개발과 다운스트림에서의 독립적인 배포가 가능합니다.
                    </p>
                </div>

                <div class="artifact-card">
                    <h4>볼트 (Bolt)</h4>
                    <p>
                        <strong>볼트(Bolt)</strong>는 AI-DLC의 가장 작은 반복으로, 유닛 또는 유닛 내 작업 세트의
                        빠른 구현을 위해 설계되었습니다.
                    </p>
                    <p>
                        볼트(Scrum의 스프린트와 유사)는 몇 주가 아닌 <strong>몇 시간 또는 며칠</strong> 단위로
                        측정되는 빌드-검증 주기로 강렬한 집중과 고속 제공을 강조합니다.
                    </p>
                    <p>
                        각 볼트는 잘 정의된 작업 범위(예: 유닛 내의 사용자 스토리 모음)를 캡슐화하여
                        지원하는 유닛의 전반적인 목표와의 일치를 유지하면서 점진적인 진행을 가능하게 합니다.
                    </p>
                    <p>
                        유닛은 하나 이상의 볼트를 통해 실행될 수 있으며, 이는 병렬 또는 순차적으로 실행될 수 있습니다.
                        AI가 볼트를 계획하고 개발자/제품 소유자가 이를 검증합니다.
                    </p>
                </div>

                <div class="artifact-card">
                    <h4>도메인 설계 (Domain Design)</h4>
                    <p>
                        <strong>도메인 설계</strong> 산출물은 인프라 구성 요소와 독립적으로 유닛의 핵심 비즈니스 로직을
                        모델링합니다.
                    </p>
                    <p>
                        AI-DLC의 첫 번째 버전에서 AI는 도메인 주도 설계 원칙을 사용하여 다음을 포함한
                        전략적 및 전술적 모델링 요소를 생성합니다:
                    </p>
                    <ul>
                        <li>집합체 (Aggregates)</li>
                        <li>값 객체 (Value Objects)</li>
                        <li>엔티티 (Entities)</li>
                        <li>도메인 이벤트 (Domain Events)</li>
                        <li>리포지토리 (Repositories)</li>
                        <li>팩토리 (Factories)</li>
                    </ul>
                </div>

                <div class="artifact-card">
                    <h4>논리 설계 (Logical Design)</h4>
                    <p>
                        <strong>논리 설계</strong>는 적절한 아키텍처 설계 패턴(예: CQRS, Circuit Breakers 등)을
                        선택하여 비기능 요구 사항을 충족하도록 도메인 설계를 확장하여 변환합니다.
                    </p>
                    <p>
                        AI는 개발자의 검증을 위해 아키텍처 결정 기록(ADRs)을 생성합니다. 논리 설계 사양을 통해
                        AI는 적절한 AWS 서비스와 구성을 선택하여 잘 설계된 원칙을 준수하는
                        <strong>코드 및 단위 테스트</strong>를 생성합니다.
                    </p>
                    <p>
                        이 단계에서 AI 에이전트는 단위 테스트를 수행하고 결과를 분석하며 개발자에게
                        수정 사항에 대한 권장 사항을 제공합니다.
                    </p>
                </div>

                <div class="artifact-card">
                    <h4>배포 유닛 (Deployment Units)</h4>
                    <p>
                        <strong>배포 유닛</strong>은 다음을 포함하는 운영 산출물입니다:
                    </p>
                    <ul>
                        <li>패키지된 실행 가능 코드 (예: Kubernetes 환경용 컨테이너 이미지, AWS Lambda와 같은 서버리스 함수)</li>
                        <li>구성 (예: Helm Charts)</li>
                        <li>인프라 구성 요소 (예: Terraform 또는 CFN 스택)</li>
                    </ul>
                    <p>
                        이들은 기능 수용, 보안, NFR 및 기타 위험에 대해 테스트됩니다. AI는 기능 테스트,
                        정적 및 동적 보안 테스트, 부하 테스트 시나리오를 포함한 모든 관련 테스트를 생성합니다.
                    </p>
                    <p>
                        인간이 테스트 시나리오와 케이스를 검증하고 조정한 후, AI 에이전트는 테스트 제품군을 실행하고
                        결과를 분석하며 실패 지점을 코드 변경, 구성 또는 기타 종속성과 상관시킵니다.
                    </p>
                </div>

                <h3>2. 단계 및 의식 (Phases & Rituals)</h3>

                <div class="phase-section">
                    <h3>🚀 시작 단계 (Inception Phase)</h3>
                    <p>
                        시작 단계는 의도를 포착하고 이를 개발을 위한 유닛으로 변환하는 데 중점을 둡니다.
                        이 단계는 <strong>"몹 정교화(Mob Elaboration)"</strong>라는 협업 요구사항 정교화 및
                        분해 의식을 사용합니다.
                    </p>
                    <h4>몹 정교화 (Mob Elaboration)</h4>
                    <p>
                        이는 퍼실리테이터가 이끄는 공유 화면이 있는 단일 방에서 이루어집니다.
                        몹 정교화 중에 AI는 도메인 지식과 느슨한 결합 및 높은 응집력의 원칙을 활용하여
                        의도를 사용자 스토리, 수용 기준 및 유닛으로 초기 분해를 제안하는 중심 역할을 합니다.
                    </p>
                    <p>
                        제품 소유자, 개발자, QA 및 기타 관련 이해관계자(몹)는 협력하여 이러한 AI 생성 산출물을
                        검토하고 개선하며, 과소 설계되거나 과도하게 설계된 부분을 조정하고 실제 제약 조건과
                        일치시킵니다.
                    </p>
                    <h4>📦 산출물:</h4>
                    <ul>
                        <li>잘 정의된 유닛 및 각각의 구성 요소:
                            <ul>
                                <li>PRFAQ</li>
                                <li>사용자 스토리</li>
                                <li>비기능 요구사항(NFR) 정의</li>
                                <li>위험 설명 (조직의 위험 등록부와 일치하는 경우)</li>
                                <li>비즈니스 의도를 추적하는 측정 기준</li>
                                <li>유닛을 구성하는 데 사용할 수 있는 제안된 볼트</li>
                            </ul>
                        </li>
                    </ul>
                    <p class="highlight">
                        💡 몹 정교화는 몇 주 또는 심지어 몇 달의 순차적 작업을 몇 시간으로 압축하면서
                        몹 내부 및 몹과 AI 간의 깊은 일치를 달성합니다.
                    </p>
                </div>

                <div class="phase-section">
                    <h3>🔨 구축 단계 (Construction Phase)</h3>
                    <p>
                        구축 단계는 작업의 반복적 실행을 포함하여 시작 단계에서 정의된 유닛을 테스트되고
                        운영 준비가 된 배포 유닛으로 변환합니다.
                    </p>
                    <h4>프로세스 흐름:</h4>
                    <ol>
                        <li><strong>도메인 설계:</strong> AI가 기술적 고려 사항과 독립적으로 비즈니스 로직을 모델링</li>
                        <li><strong>논리 설계:</strong> 비기능 요구사항 및 적절한 클라우드 설계 패턴 적용</li>
                        <li><strong>코드 생성:</strong> AI가 구성 요소를 적절한 AWS 서비스에 매핑하여 상세한 코드 생성</li>
                        <li><strong>자동화된 테스트:</strong> 기능, 보안 및 운영 준비 상태 보장</li>
                    </ol>
                    <p>
                        개발자는 각 단계에서 AI 생성 출력을 검증하고 중요한 결정을 내리는 데 집중하여
                        각 반복에서 품질과 적응성을 보장합니다.
                    </p>
                    <h4>브라운필드 시나리오:</h4>
                    <p>
                        기존 애플리케이션 시나리오에서 구축 단계는 먼저 코드를 의미론적으로 풍부한 모델링 표현으로
                        상승시켜 AI에 대한 컨텍스트가 간결하고 정확하도록 합니다.
                    </p>
                    <p>제안된 모델링 표현:</p>
                    <ul>
                        <li><strong>정적 모델:</strong> 도메인 구성 요소, 책임 및 관계만</li>
                        <li><strong>동적 모델:</strong> 중요한 사용 사례를 실현하기 위해 구성 요소가 상호 작용하는 방법</li>
                    </ul>
                    <h4>몹 구축 (Mob Construction)</h4>
                    <p>
                        AI-DLC는 몹 정교화와 유사하게 모든 팀이 단일 방에 함께 배치되어 이 작업을 수행할 것을 권장합니다.
                        팀은 통합 사양(도메인 모델 단계에서)을 교환하고 결정을 내리고 볼트를 제공합니다.
                    </p>
                </div>

                <div class="phase-section">
                    <h3>⚙️ 운영 단계 (Operations Phase)</h3>
                    <p>
                        AI-DLC의 운영 단계는 AI를 활용하여 운영 효율성을 높이는 시스템의 배포, 관찰 가능성 및
                        유지 관리에 중점을 둡니다.
                    </p>
                    <h4>AI의 역할:</h4>
                    <ul>
                        <li><strong>텔레메트리 분석:</strong> 메트릭, 로그 및 추적을 적극적으로 분석하여 패턴 감지,
                            이상 징후 식별, 잠재적 SLA 위반 예측</li>
                        <li><strong>사전 대응:</strong> 사전 정의된 인시던트 런북과 통합하여 리소스 확장, 성능 튜닝 또는
                            장애 격리와 같은 실행 가능한 권장 사항 제안</li>
                        <li><strong>자동 실행:</strong> 개발자가 승인하면 해결 방안 실행</li>
                    </ul>
                    <p>
                        개발자는 검증자 역할을 하여 AI 생성 인사이트와 제안된 조치가 SLA 및 규정 준수 요구 사항과
                        일치하도록 보장합니다.
                    </p>
                </div>

                <h3>3. 워크플로</h3>

                <img src="workflow.png" alt="AI-DLC 워크플로" class="diagram-image">

                <div class="workflow-diagram">
                    <h4>📊 AI-DLC 워크플로</h4>
                    <p>
                        비즈니스 의도(예: 그린필드 개발, 브라운필드 개선, 현대화 또는 결함 수정)가 주어지면,
                        AI-DLC는 의도를 구현하기 위한 워크플로를 설명하는 <strong>레벨 1 계획</strong>을
                        생성하도록 AI에 프롬프트하는 것으로 시작합니다.
                    </p>
                    <p>
                        이 계획은 초기 제안 역할을 하며, 인간에 의해 투명하게 검토, 검증 및 개선되어
                        비즈니스 목표 및 엔지니어링 제약 조건과의 일치를 보장합니다.
                    </p>
                    <h4>핵심 원칙:</h4>
                    <ol>
                        <li>각 단계에서 <strong>인간 감독</strong>을 적용하여 산출물을 점진적으로 풍부하게 하여
                            다음 단계를 위한 의미론적으로 풍부한 컨텍스트로 변환</li>
                        <li>각 단계는 <strong>전략적 결정 지점</strong> 역할을 하며, 인간 감독은 손실 함수처럼 작동 -
                            다운스트림으로 눈덩이처럼 커지기 전에 오류를 조기에 포착하고 수정</li>
                        <li>레벨 1 계획의 각 단계는 AI에 의해 더 세밀한 실행 가능한 하위 작업으로 분해되며,
                            정확성과 맥락적 적절성을 보장하기 위해 인간 감독 하에</li>
                        <li>생성된 모든 산출물(의도, 사용자 스토리, 도메인 모델 또는 테스트 계획)은 지속되며
                            AI가 라이프사이클 전반에 걸쳐 참조하는 <strong>"컨텍스트 메모리"</strong> 역할</li>
                    </ol>
                    <p class="highlight">
                        💡 전통적인 SDLC 방법과 마찬가지로 AI-DLC는 본질적으로 반복적이며,
                        지속적인 개선과 적응을 허용합니다.
                    </p>
                </div>
            </section>

            <!-- IV. 그린필드 개발 -->
            <section id="greenfield">
                <h2>IV. AI-DLC 실전: 그린필드 개발</h2>
                <p>
                    제품 소유자가 "교차 판매 제품을 위한 추천 엔진 개발"과 같은 높은 수준의 의도를 명시하여
                    프로세스를 시작하는 시나리오를 살펴보겠습니다.
                </p>

                <div class="note">
                    <strong>🔄 프로세스 흐름:</strong><br>
                    AI는 이를 새로운 애플리케이션을 구축하려는 의도로 인식하고 레벨 1 계획을 생성합니다.
                    팀이 검증하고 레벨 1 계획의 단계를 추가/수정합니다. 최종 레벨 1 계획을 통해 AI는 시작 단계로 진행합니다.
                </div>

                <h3>1. 시작 단계</h3>
                <h4>몹 정교화 의식의 주요 상호작용:</h4>
                <ol>
                    <li>AI가 명확한 질문을 함 (예: "주요 사용자는 누구입니까? 이것이 달성해야 하는 주요 비즈니스 결과는 무엇입니까?")</li>
                    <li>AI가 명확해진 의도를 사용자 스토리, NFR 및 위험 설명으로 정교화</li>
                    <li>AI가 높은 응집력을 가진 스토리를 유닛으로 구성 (예: "사용자 데이터 수집", "추천 알고리즘 선택", "API 통합")</li>
                    <li>제품 소유자가 이러한 출력을 검증하고 유닛을 개선하기 위해 필요한 곳에서 조정</li>
                    <li>AI가 모듈에 대한 PRFAQ를 생성 (선택사항)</li>
                    <li>개발자와 제품 소유자가 PRFAQ 및 관련 위험을 검증</li>
                </ol>

                <h3>2. 구축 단계</h3>
                <h4>몹 프로그래밍 및 몹 테스팅 의식:</h4>
                <ol>
                    <li><strong>세션 시작:</strong> 개발자가 AI와 세션을 설정. AI가 할당된 유닛으로 시작하도록 프롬프트</li>
                    <li><strong>도메인 모델링:</strong> AI가 DDD 원칙을 사용하여 할당된 유닛의 핵심 비즈니스 로직 모델링</li>
                    <li><strong>검증:</strong> 개발자가 도메인 모델을 검토하고 검증하며, 비즈니스 로직을 개선하고 실제 시나리오와의 일치 보장</li>
                    <li><strong>논리 설계:</strong> AI가 도메인 모델을 논리 설계로 변환하여 NFR 적용 (예: 확장성, 장애 허용)</li>
                    <li><strong>아키텍처 결정:</strong> 개발자가 AI의 권장 사항을 평가하고 트레이드오프를 승인하며 필요한 경우 추가 고려 사항 제안</li>
                    <li><strong>코드 생성:</strong> AI가 각 유닛에 대해 실행 가능한 코드를 생성하고 논리 구성 요소를 특정 AWS 서비스에 매핑</li>
                </ol>

                <img src="ai-domain-specific_ai_agent.png" alt="도메인 특화 AI 에이전트" class="diagram-image">

                <ol start="7">
                    <li><strong>테스트 생성:</strong> AI가 기능, 보안 및 성능 테스트를 자동 생성</li>
                    <li><strong>코드 검토:</strong> 개발자가 생성된 코드와 테스트 시나리오/케이스를 검토하고 품질과 규정 준수를 보장하기 위해 필요한 조정 수행</li>
                </ol>

                <h4>테스트 및 검증:</h4>
                <ol>
                    <li>AI가 모든 테스트를 실행하고 결과를 분석하며 문제를 강조</li>
                    <li>실패한 테스트에 대한 수정 제안 (예: 더 나은 성능을 위해 쿼리 로직 최적화)</li>
                    <li>개발자가 AI의 발견 사항을 검증하고 수정을 승인하며 필요에 따라 테스트를 다시 실행</li>
                </ol>

                <h3>3. 운영 단계</h3>
                <h4>배포:</h4>
                <ul>
                    <li>AI가 모듈을 배포 유닛(예: 컨테이너 이미지, 서버리스 함수)으로 패키징</li>
                    <li>개발자가 배포 구성을 승인하고 스테이징 및 프로덕션 환경으로의 롤아웃 시작</li>
                </ul>

                <h4>관찰 가능성 및 모니터링:</h4>
                <ul>
                    <li>AI가 메트릭, 로그 및 추적을 분석하여 이상 징후를 식별하고 잠재적 SLA 위반 예측</li>
                    <li>AI가 플레이북과 통합하여 운영 문제에 대한 조치 제안</li>
                    <li>개발자가 AI의 권장 사항을 검증하고 완화 조치를 승인하며 해결 결과 모니터링</li>
                </ul>
            </section>

            <!-- V. 브라운필드 개발 -->
            <section id="brownfield">
                <h2>V. AI-DLC 실전: 브라운필드 개발</h2>
                <p>
                    브라운필드는 새로운 기능 추가, 비기능 요구사항 최적화 또는 리팩토링 및 결함 수정을 포함한
                    기술 부채 수정 측면에서 기존 시스템을 변경하는 것을 의미합니다.
                </p>
                <p>
                    이 맥락에서 제품 관리자가 기존 애플리케이션에 새로운 기능을 추가해야 하는 시나리오를 살펴보겠습니다.
                </p>

                <h3>1. 시작 단계</h3>
                <p>
                    브라운필드의 시작 단계 활동은 그린필드와 동일합니다.
                </p>

                <h3>2. 구축 단계</h3>
                <div class="note">
                    <strong>🔍 추가 단계:</strong>
                    <ol>
                        <li><strong>코드 상승:</strong> AI가 코드를 더 높은 수준의 모델링 표현으로 상승시킵니다.
                            모델은 정적 모델(구성 요소, 설명, 책임 및 관계)과 동적 모델(가장 중요한 사용 사례를
                            실현하기 위해 구성 요소가 상호 작용하는 방법)로 구성됩니다.</li>
                        <li><strong>검증:</strong> 개발자가 제품 관리자와 협력하여 AI에 의해 역 엔지니어링된
                            정적 및 동적 모델을 검토, 검증 및 수정합니다.</li>
                        <li><strong>구축 계속:</strong> 이러한 추가 단계를 통해 나머지 구축 단계는 그린필드 시나리오와 유사합니다.</li>
                    </ol>
                </div>

                <h3>3. 운영 단계</h3>
                <p>
                    브라운필드의 운영 단계 활동은 그린필드와 동일합니다.
                </p>
            </section>

            <!-- VI. AI-DLC 도입 -->
            <section id="adoption">
                <h2>VI. AI-DLC 도입</h2>
                <p>
                    AI-DLC는 기존 Agile 방법에서 크게 벗어나지 않으며 더 쉬운 채택을 주요 결과로 설계되었습니다.
                    그러나 전통적인 방법을 오랫동안 실천해 온 조직과 자체 AI 네이티브 방법 변형을 발명하는
                    과정에 있는 조직은 AI-DLC를 채택하기 위한 구체적인 전략이 필요합니다.
                </p>

                <h3>채택 접근 방식</h3>

                <div class="principle-box">
                    <h3>a. 실천을 통한 학습 (Learning by Practicing)</h3>
                    <p>
                        AI-DLC는 실제로 그룹으로 실천할 수 있는 일련의 의식(몹 정교화, 몹 구축 등)입니다.
                    </p>
                    <p>
                        문서와 전통적인 교육을 통해 방법을 배우는 대신, 실무자들이 현재 해결하고 있는 여러
                        실제 시나리오에서 AI-DLC 가이드와 함께 의식을 실천하도록 할 것입니다.
                    </p>
                    <p class="highlight">
                        <strong>AWS 솔루션 아키텍트</strong>는 대규모 조직에서의 대규모 채택을 위해
                        이 접근 방식을 패키징한 <strong>AI-DLC Unicorn Gym</strong>이라는 현장 제안을 만들었습니다.
                    </p>
                </div>

                <div class="principle-box">
                    <h3>b. 새로운 개발자 경험 도구에 AI-DLC 내장</h3>
                    <p>
                        고객들은 SDLC 전반에 걸쳐 통합된 경험을 제공하는 자체 오케스트레이션 도구를 구축하고 있습니다.
                    </p>
                    <p>예시:</p>
                    <ul>
                        <li>Cognizant의 FlowSource</li>
                        <li>Aspire의 CodeSpell</li>
                        <li>HCL의 AIForce</li>
                    </ul>
                    <p>
                        이러한 도구에 AI-DLC를 내장함으로써, 대규모 조직의 개발자는 중요한 채택 드라이브 없이
                        원활하게 AI-DLC를 실천할 것입니다.
                    </p>
                </div>
            </section>

            <!-- 부록 A -->
            <section id="appendix">
                <h2>부록 A: 프롬프트 예시</h2>
                <p>
                    AI-DLC를 실천하기 위해 AI와 상호작용하는 데 다음 프롬프트를 사용할 수 있습니다.
                </p>

                <h3>설정 프롬프트</h3>
                <div class="code-block">
오늘 우리는 애플리케이션 구축 작업을 할 것입니다. 모든 프론트엔드 및 백엔드 구성 요소에 대해
프로젝트 폴더를 만들 것입니다. 모든 문서는 aidlc-docs 폴더에 저장됩니다.

세션 전반에 걸쳐 작업을 미리 계획하고 계획에 대한 md 파일을 만들도록 요청할 것입니다.
제가 해당 계획을 승인한 후에만 작업할 수 있습니다. 이러한 계획은 항상 aidlc-docs/plans 폴더에 저장됩니다.

요구사항, 기능 변경 문서는 aidlc-docs/requirements 폴더에 저장됩니다.
사용자 스토리는 aidlc-docs/story-artifacts 폴더에 저장되어야 합니다.
아키텍처 및 설계 문서는 aidlc-docs/design-artifacts 폴더에 저장되어야 합니다.
순서대로 모든 프롬프트는 aidlc-docs/prompts.md 파일에 저장되어야 합니다.

이 프롬프트에 대한 이해를 확인하십시오. 필요한 폴더와 파일이 아직 없으면 생성하십시오.
                </div>

                <h3>시작 단계: 사용자 스토리</h3>
                <div class="code-block">
역할: 당신은 전문 제품 관리자이며 아래 작업 섹션에 언급된 시스템 개발을 위한 계약이 되는
잘 정의된 사용자 스토리를 만드는 임무를 맡고 있습니다.

앞으로의 작업을 계획하고 계획의 각 단계에 대해 체크박스가 있는 md 파일(user_stories_plan.md)에
단계를 작성하십시오. 단계에 제 확인이 필요한 경우 단계에 메모를 추가하여 제 확인을 받으십시오.

중요한 결정을 혼자 내리지 마십시오. 계획을 완료한 후 제 검토 및 승인을 요청하십시오.
제 승인 후 동일한 계획을 한 번에 한 단계씩 실행할 수 있습니다. 각 단계를 완료하면
계획의 체크박스를 완료로 표시하십시오.

작업: <<제품 설명 여기에 기술>>에 설명된 높은 수준의 요구사항에 대한 사용자 스토리를 구축하십시오.

<<계획을 검토하고 변경한 후>>
네, <<md 파일>>의 계획이 마음에 듭니다. 이제 정확히 동일한 계획을 따르십시오.
계획에 지정된 대로 저와 상호작용하십시오. 각 단계를 완료하면 계획의 체크박스를 표시하십시오.
                </div>

                <h3>시작 단계: 유닛</h3>
                <div class="code-block">
역할: 당신은 경험이 풍부한 소프트웨어 아키텍트입니다. 아래에 언급된 작업을 시작하기 전에
계획을 수립하고 계획의 각 단계에 대해 체크박스가 있는 units_plan.md 파일에 단계를 작성하십시오.

작업: mvp_user_stories.md 파일의 사용자 스토리를 참조하십시오. 사용자 스토리를 독립적으로
구축할 수 있는 여러 유닛으로 그룹화하십시오. 각 유닛에는 단일 팀이 구축할 수 있는
높은 응집력을 가진 사용자 스토리가 포함됩니다. 유닛은 서로 느슨하게 결합되어 있습니다.

각 유닛에 대해 design/ 폴더의 개별 md 파일에 각각의 사용자 스토리와 수용 기준을 작성하십시오.
                </div>

                <h3>구축 단계: 도메인 모델 생성</h3>
                <div class="code-block">
역할: 당신은 경험이 풍부한 소프트웨어 엔지니어입니다.

작업: design/seo_optimization_unit.md 파일의 사용자 스토리를 참조하십시오.
모든 사용자 스토리를 구현하기 위한 구성 요소 모델을 설계하십시오.
이 모델은 모든 구성 요소, 속성, 동작 및 사용자 스토리를 구현하기 위해 구성 요소가
상호 작용하는 방법을 포함해야 합니다.

아직 코드를 생성하지 마십시오. 구성 요소 모델을 /design 폴더의 별도 md 파일에 작성하십시오.
                </div>

                <h3>구축 단계: 코드 생성</h3>
                <div class="code-block">
역할: 당신은 경험이 풍부한 소프트웨어 엔지니어입니다.

작업: search_discovery/nlp_component.md 파일의 구성 요소 설계를 참조하십시오.
설계에 있는 자연어 처리(NLP) 구성 요소에 대한 매우 간단하고 직관적인 Python 구현을 생성하십시오.

processQuery(queryText) 메서드의 경우 amazon bedrock API를 사용하여 쿼리 텍스트에서
엔티티를 추출하십시오. 각각의 개별 파일에 클래스를 생성하되 vocabMapper 디렉토리에 보관하십시오.
                </div>

                <h3>구축 단계: 아키텍처</h3>
                <div class="code-block">
역할: 당신은 경험이 풍부한 클라우드 아키텍트입니다.

작업: 구성 요소 설계 모델(design/core_component_model.md), UNITS/ 폴더의 유닛,
ARCHITECTURE/ 폴더의 클라우드 아키텍처, BACKEND/ 폴더의 백엔드 코드를 참조하십시오.

다음을 완료하십시오:
- [CloudFormation, CDK, Terraform]을 사용하여 AWS 클라우드에 백엔드를 배포하기 위한
  엔드투엔드 계획 생성
- 배포를 위한 모든 전제 조건 문서화(있는 경우)

제가 계획을 승인한 후:
- 깨끗하고 간단하며 설명 가능한 코딩의 모범 사례를 따르십시오
- 모든 출력 코드는 DEPLOYMENT/ 폴더에 저장됩니다
- 생성된 코드가 의도한 대로 작동하는지 검증 계획을 작성하고 검증 보고서를 생성하십시오
- 검증 보고서를 검토하고 식별된 모든 문제를 수정하고 검증 보고서를 업데이트하십시오
                </div>
            </section>

        </div>

        <footer>
            <p>&copy; 2025 Amazon Web Services - AI 주도 개발 라이프사이클 (AI-DLC)</p>
            <p style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
                이 문서는 AWS의 AI-DLC 방법론 백서를 한글로 번역한 것입니다
            </p>
        </footer>
    </div>
</body>
</html>
